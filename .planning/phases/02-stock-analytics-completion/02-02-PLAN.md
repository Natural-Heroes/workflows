---
phase: 02-stock-analytics-completion
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - mcp/inventory-planner/src/mcp/tools/variants.ts
  - mcp/inventory-planner/src/mcp/tools/reference.ts
  - mcp/inventory-planner/src/mcp/tools/reference.test.ts
  - mcp/inventory-planner/src/mcp/tools/index.ts
autonomous: true

must_haves:
  truths:
    - "User can list available warehouses to understand filtering options"
    - "User can list available vendors to understand PO creation options"
    - "Reference data extracted from variant responses (no dedicated API endpoints)"
    - "Both tools return LLM-friendly summaries with count"
  artifacts:
    - path: "mcp/inventory-planner/src/mcp/tools/reference.ts"
      provides: "list_warehouses and list_vendors MCP tools"
      exports: ["registerReferenceTools"]
      min_lines: 80
    - path: "mcp/inventory-planner/src/mcp/tools/reference.test.ts"
      provides: "Tests for reference data tools"
      min_lines: 100
  key_links:
    - from: "reference.ts"
      to: "client.getVariants"
      via: "Fetches variants with fields filter to extract unique warehouses/vendors"
      pattern: "client\\.getVariants.*fields.*warehouse|vendor"
    - from: "mcp/tools/index.ts"
      to: "reference.ts"
      via: "Import and registration"
      pattern: "registerReferenceTools"
---

<objective>
Implement list_warehouses and list_vendors tools that extract reference data from variant responses, since Inventory Planner API does not expose dedicated endpoints.

Purpose: Fulfill REF-01 (list warehouses) and REF-02 (list vendors) requirements
Output: reference.ts with both tools, reference.test.ts with tests, updated index.ts
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-stock-analytics-completion/02-RESEARCH.md

# Existing tool registration pattern
@mcp/inventory-planner/src/mcp/tools/index.ts
@mcp/inventory-planner/src/mcp/tools/variants.ts

# Test patterns
@mcp/inventory-planner/src/__tests__/mcp-session.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create reference.ts with list_warehouses and list_vendors tools</name>
  <files>mcp/inventory-planner/src/mcp/tools/reference.ts</files>
  <action>
Create a new file for reference data tools that extract warehouses and vendors from variant responses.

**Implementation:**

```typescript
/**
 * MCP Tools: Reference Data
 *
 * Provides tools for accessing reference data (warehouses, vendors).
 * Since Inventory Planner API doesn't expose dedicated endpoints for
 * these resources, we extract unique values from variant responses.
 */

import { z } from 'zod';
import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import type { InventoryPlannerClient } from '../../services/inventory-planner/index.js';
import { logger } from '../../lib/logger.js';
import { handleToolError } from './error-handler.js';

/**
 * Registers reference data MCP tools with the server.
 *
 * @param server - The MCP server instance
 * @param client - The Inventory Planner API client
 */
export function registerReferenceTools(
  server: McpServer,
  client: InventoryPlannerClient
): void {
  // list_warehouses - Get available warehouses
  server.tool(
    'list_warehouses',
    'Get available warehouses/locations. Use this to understand filtering options for variants and purchase orders. Warehouses are extracted from variant data.',
    {
      limit: z
        .number()
        .int()
        .min(1)
        .max(100)
        .default(50)
        .describe('Maximum warehouses to return'),
    },
    async (params) => {
      logger.debug('list_warehouses tool called', { params });

      try {
        // Fetch variants with warehouse fields only
        // Using high limit to get representative sample
        const response = await client.getVariants({
          fields: 'warehouse_id,warehouse_name',
          limit: 1000,
        });

        // Extract unique warehouses
        const warehouseMap = new Map<string, string>();
        for (const v of response.data) {
          if (v.warehouse_id && v.warehouse_name) {
            warehouseMap.set(v.warehouse_id, v.warehouse_name);
          }
        }

        const warehouses = Array.from(warehouseMap.entries())
          .slice(0, params.limit)
          .map(([id, name]) => ({ id, name }));

        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({
                summary: `${warehouses.length} warehouse(s) found.`,
                warehouses,
                note: warehouses.length >= params.limit
                  ? 'Results limited. Increase limit parameter to see more.'
                  : 'All available warehouses shown.',
              }),
            },
          ],
        };
      } catch (error) {
        return handleToolError(error, 'list_warehouses');
      }
    }
  );

  // list_vendors - Get available vendors
  server.tool(
    'list_vendors',
    'Get available vendors/suppliers. Use this to understand options for filtering variants or creating purchase orders. Vendors are extracted from variant data.',
    {
      limit: z
        .number()
        .int()
        .min(1)
        .max(100)
        .default(50)
        .describe('Maximum vendors to return'),
    },
    async (params) => {
      logger.debug('list_vendors tool called', { params });

      try {
        // Fetch variants with vendor fields only
        const response = await client.getVariants({
          fields: 'vendor_id,vendor_name,vendors',
          limit: 1000,
        });

        // Extract unique vendors from both vendor_id/vendor_name and vendors array
        const vendorMap = new Map<string, string>();
        for (const v of response.data) {
          // Primary vendor
          if (v.vendor_id && v.vendor_name) {
            vendorMap.set(v.vendor_id, v.vendor_name);
          }
          // Additional vendors from vendors array (if present)
          if (Array.isArray(v.vendors)) {
            for (const vendor of v.vendors) {
              if (vendor.id && vendor.name) {
                vendorMap.set(vendor.id, vendor.name);
              }
            }
          }
        }

        const vendors = Array.from(vendorMap.entries())
          .slice(0, params.limit)
          .map(([id, name]) => ({ id, name }));

        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({
                summary: `${vendors.length} vendor(s) found.`,
                vendors,
                note: vendors.length >= params.limit
                  ? 'Results limited. Increase limit parameter to see more.'
                  : 'All available vendors shown.',
              }),
            },
          ],
        };
      } catch (error) {
        return handleToolError(error, 'list_vendors');
      }
    }
  );

  logger.info('Reference data tools registered');
}
```

**Key design decisions:**
- Extract from variants because API has no dedicated endpoints (per research)
- Use Map to deduplicate by ID
- Check both vendor_id/vendor_name and vendors array (variants can have multiple vendors)
- Include helpful note about result limits
- Use handleToolError for consistent error responses
  </action>
  <verify>
File exists and exports registerReferenceTools function.
TypeScript compiles: `cd mcp/inventory-planner && npx tsc --noEmit`
  </verify>
  <done>reference.ts created with list_warehouses and list_vendors tools</done>
</task>

<task type="auto">
  <name>Task 2: Register reference tools in index.ts</name>
  <files>mcp/inventory-planner/src/mcp/tools/index.ts</files>
  <action>
Update the tool index to import and register the reference data tools.

**Changes needed:**

1. Add import at top (after other tool imports):
```typescript
import { registerReferenceTools } from './reference.js';
```

2. Add to INSTRUCTIONS_RESOURCE (in the "## Available Tools" section, add after Variants):
```typescript
### Reference Data
- **list_warehouses**: Get available warehouses/locations for filtering context.
- **list_vendors**: Get available vendors/suppliers for PO creation and filtering.
```

3. Add registration call in createMcpServer() (after registerMutationTools):
```typescript
registerReferenceTools(server, client);
```

4. Update the comment block listing what's registered:
```typescript
 * - Reference tools (list_warehouses, list_vendors)
```
  </action>
  <verify>
TypeScript compiles: `cd mcp/inventory-planner && npx tsc --noEmit`
tools/list returns list_warehouses and list_vendors tools (can verify in later integration test)
  </verify>
  <done>Reference tools imported and registered in createMcpServer()</done>
</task>

<task type="auto">
  <name>Task 3: Create reference.test.ts with comprehensive tests</name>
  <files>mcp/inventory-planner/src/mcp/tools/reference.test.ts</files>
  <action>
Create integration tests for the reference data tools.

**Test file structure (same patterns as variants.test.ts):**

```typescript
// Set fake environment variables before importing app
process.env.INVENTORY_PLANNER_API_KEY = 'test-key';
process.env.INVENTORY_PLANNER_ACCOUNT_ID = 'test-account';

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import createFetchMock from 'vitest-fetch-mock';
import request from 'supertest';
import { app, transports } from '../../app.js';
import { resetInventoryPlannerClient } from '../../services/inventory-planner/index.js';

const fetchMocker = createFetchMock(vi);
const MCP_ACCEPT_HEADER = 'application/json, text/event-stream';

// Helper functions (parseSSEResponse, initializeSession, callTool)
// Copy from variants.test.ts or mcp-session.test.ts
```

**Test suites needed:**

1. **list_warehouses tool (REF-01)**
   - Returns unique warehouses from variant data
   - Deduplicates by warehouse_id
   - Respects limit parameter
   - Returns summary with count
   - Returns note about results
   - Handles empty variants (no warehouses found)
   - Returns LLM-friendly error on API failure

2. **list_vendors tool (REF-02)**
   - Returns unique vendors from variant data
   - Extracts from vendor_id/vendor_name fields
   - Extracts from vendors array (multiple vendors per variant)
   - Deduplicates by vendor_id
   - Respects limit parameter
   - Returns summary with count
   - Handles empty variants (no vendors found)
   - Returns LLM-friendly error on API failure

**Mock API response for list_warehouses:**
```typescript
fetchMocker.mockResponseOnce(JSON.stringify({
  result: { status: 'success' },
  meta: { name: 'variants', total: 3, count: 3, limit: 1000 },
  variants: [
    { warehouse_id: 'wh-1', warehouse_name: 'Main Warehouse' },
    { warehouse_id: 'wh-2', warehouse_name: 'East Coast DC' },
    { warehouse_id: 'wh-1', warehouse_name: 'Main Warehouse' }, // duplicate
  ],
}));
```

**Mock API response for list_vendors (with vendors array):**
```typescript
fetchMocker.mockResponseOnce(JSON.stringify({
  result: { status: 'success' },
  meta: { name: 'variants', total: 2, count: 2, limit: 1000 },
  variants: [
    {
      vendor_id: 'v-1',
      vendor_name: 'Acme Corp',
      vendors: [
        { id: 'v-1', name: 'Acme Corp' },
        { id: 'v-2', name: 'Backup Supplier' },
      ],
    },
    {
      vendor_id: 'v-3',
      vendor_name: 'Widget Co',
    },
  ],
}));
```

**Test assertions:**
- For list_warehouses: 2 unique warehouses returned (wh-1 deduplicated)
- For list_vendors: 3 unique vendors returned (v-1 from both fields deduplicated)
  </action>
  <verify>
Run tests: `cd mcp/inventory-planner && npm test`
All reference.test.ts tests pass.
Coverage includes:
- list_warehouses: extraction, deduplication, limits, errors
- list_vendors: extraction from both sources, deduplication, limits, errors
  </verify>
  <done>
reference.test.ts created with tests covering:
- REF-01: list_warehouses returns unique warehouses from variants
- REF-02: list_vendors returns unique vendors from variants and vendors array
All tests pass.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **Test suite passes:**
   ```bash
   cd mcp/inventory-planner && npm test
   ```
   All tests pass including new reference.test.ts

2. **Build succeeds:**
   ```bash
   cd mcp/inventory-planner && npm run build
   ```

3. **Tools registered:**
   The tools/list response includes list_warehouses and list_vendors

4. **Requirement verification:**
   - REF-01: list_warehouses extracts unique warehouses from variant data
   - REF-02: list_vendors extracts unique vendors from variant data and vendors array
</verification>

<success_criteria>
- reference.ts exists with list_warehouses and list_vendors tools
- reference.test.ts exists with 10+ tests
- index.ts updated to import and register reference tools
- All tests pass (`npm test` exits 0)
- Tests cover REF-01 and REF-02 requirements
- Build succeeds (`npm run build` exits 0)
</success_criteria>

<output>
After completion, create `.planning/phases/02-stock-analytics-completion/02-02-SUMMARY.md`
</output>
