---
phase: 03-rate-limiting-resilience
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - mcp/mrpeasy/src/services/mrpeasy/client.ts
  - mcp/mrpeasy/src/services/mrpeasy/index.ts
autonomous: true
---

<objective>
Integrate rate limiting, request queue, retry logic, and circuit breaker into the MRPeasy API client.

Purpose: Wire all resilience utilities into the existing MrpEasyClient so all API calls automatically benefit from rate limiting, queuing, retries, and circuit breaker protection.
Output: Production-ready API client that handles MRPeasy's strict rate limits gracefully.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-rate-limiting-resilience/03-01-SUMMARY.md

@mcp/mrpeasy/src/services/mrpeasy/client.ts
@mcp/mrpeasy/src/services/mrpeasy/index.ts
@mcp/mrpeasy/src/services/mrpeasy/rate-limiter.ts
@mcp/mrpeasy/src/services/mrpeasy/request-queue.ts
@mcp/mrpeasy/src/services/mrpeasy/retry.ts
@mcp/mrpeasy/src/services/mrpeasy/circuit-breaker.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate resilience into MrpEasyClient</name>
  <files>mcp/mrpeasy/src/services/mrpeasy/client.ts</files>
  <action>
Update MrpEasyClient to use all resilience utilities:

1. Import utilities:
   ```typescript
   import { TokenBucket, createRateLimiter } from './rate-limiter.js';
   import { RequestQueue, createRequestQueue } from './request-queue.js';
   import { withRetry } from './retry.js';
   import { CircuitBreaker, createCircuitBreaker, CircuitBreakerOpenError } from './circuit-breaker.js';
   ```

2. Add to MrpEasyClientConfig (optional overrides):
   ```typescript
   export interface MrpEasyClientConfig {
     apiKey: string;
     apiSecret: string;
     baseUrl?: string;
     // Resilience options (all optional with sensible defaults)
     maxRetries?: number;
     circuitBreakerEnabled?: boolean;
   }
   ```

3. Add private instance properties:
   ```typescript
   private readonly rateLimiter: TokenBucket;
   private readonly queue: RequestQueue;
   private readonly circuitBreaker: CircuitBreaker;
   private readonly maxRetries: number;
   ```

4. Initialize in constructor:
   ```typescript
   this.rateLimiter = createRateLimiter();
   this.queue = createRequestQueue();
   this.circuitBreaker = createCircuitBreaker();
   this.maxRetries = config.maxRetries ?? 3;
   ```

5. Update the private `request<T>()` method to wrap the actual fetch in the resilience stack:
   ```typescript
   private async request<T, P extends object = object>(
     endpoint: string,
     params?: P
   ): Promise<T> {
     // Queue ensures single concurrent request
     return this.queue.enqueue(async () => {
       // Circuit breaker protects against sustained failures
       return this.circuitBreaker.execute(async () => {
         // Retry handles transient failures (429, 503)
         return withRetry(async () => {
           // Rate limiter ensures we don't exceed 100/10s
           await this.rateLimiter.waitForToken();

           // ... existing fetch logic ...
         }, { maxAttempts: this.maxRetries });
       });
     });
   }
   ```

6. The fetch logic inside withRetry remains the same as current implementation.

7. Re-export CircuitBreakerOpenError so callers can catch it:
   ```typescript
   export { CircuitBreakerOpenError } from './circuit-breaker.js';
   ```

Ensure logging shows when requests are queued, rate limited, retried, or circuit breaker trips.
  </action>
  <verify>npx tsc --noEmit passes</verify>
  <done>MrpEasyClient uses rate limiter, queue, retry, and circuit breaker for all API calls</done>
</task>

<task type="auto">
  <name>Task 2: Update module exports</name>
  <files>mcp/mrpeasy/src/services/mrpeasy/index.ts</files>
  <action>
Update module exports to include resilience utilities:

1. Re-export types and utilities that callers might need:
   ```typescript
   // Resilience utilities (for advanced usage or testing)
   export { TokenBucket, createRateLimiter } from './rate-limiter.js';
   export { RequestQueue, createRequestQueue } from './request-queue.js';
   export { withRetry, type RetryConfig } from './retry.js';
   export { CircuitBreaker, CircuitBreakerOpenError, createCircuitBreaker } from './circuit-breaker.js';
   ```

2. Ensure existing exports remain unchanged:
   - All types from types.ts
   - MrpEasyClient class
   - MrpEasyApiError class
   - createMrpEasyClient factory

3. The factory function `createMrpEasyClient()` continues to work as before - resilience is internal to the client.
  </action>
  <verify>npm run typecheck passes</verify>
  <done>All resilience utilities exported from module index</done>
</task>

<task type="auto">
  <name>Task 3: Add resilience logging</name>
  <files>mcp/mrpeasy/src/services/mrpeasy/client.ts</files>
  <action>
Enhance logging to show resilience events:

1. In the request method, add logging for:
   - When request is queued (debug): "Request queued" with endpoint
   - When rate limiting causes wait (debug): "Rate limited, waiting for token"
   - When retry occurs (warn): "Retrying request" with attempt number and delay
   - When circuit breaker opens (error): "Circuit breaker opened"
   - When circuit breaker closes (info): "Circuit breaker closed"

2. Log at appropriate levels:
   - Debug: Normal operation details (queuing, rate limiting)
   - Warn: Retries (transient issues)
   - Error: Circuit breaker state changes (sustained issues)

3. Example logging in request method:
   ```typescript
   return this.queue.enqueue(async () => {
     logger.debug('Request queued', { endpoint });

     return this.circuitBreaker.execute(async () => {
       return withRetry(async () => {
         logger.debug('Waiting for rate limit token', { endpoint });
         await this.rateLimiter.waitForToken();
         logger.debug('Token acquired, sending request', { endpoint });

         // ... fetch logic ...
       }, { maxAttempts: this.maxRetries });
     });
   });
   ```

This makes it easy to diagnose rate limiting and resilience behavior in production.
  </action>
  <verify>npm run typecheck passes</verify>
  <done>Comprehensive logging for all resilience events</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run typecheck` passes
- [ ] All API calls go through: queue → circuit breaker → retry → rate limiter → fetch
- [ ] Resilience utilities exported from index.ts
- [ ] Logging shows queue, rate limit, retry, and circuit breaker events
- [ ] Existing tool implementations continue to work unchanged
</verification>

<success_criteria>
- All tasks completed
- TypeScript compiles without errors
- MrpEasyClient is now resilient to rate limits and transient failures
- Tools don't need any changes (resilience is transparent)
- Behavior: max 1 concurrent request, max 100/10s, auto-retry on 429/503, circuit breaker on sustained failures
</success_criteria>

<output>
After completion, create `.planning/phases/03-rate-limiting-resilience/03-02-SUMMARY.md`
</output>
