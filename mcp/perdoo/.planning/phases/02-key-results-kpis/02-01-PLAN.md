---
phase: 02-key-results-kpis
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/perdoo/operations/key-results.ts
  - src/services/perdoo/types.ts
  - src/services/perdoo/client.ts
  - src/mcp/tools/key-results.ts
  - src/mcp/tools/index.ts
autonomous: true

must_haves:
  truths:
    - "LLM can list key results with filtering by parent objective, lead, type, and status"
    - "LLM can get a single key result by ID with full details including parent objective reference"
    - "LLM can create a key result under a specific objective"
    - "LLM can update an existing key result's properties"
  artifacts:
    - path: "src/services/perdoo/operations/key-results.ts"
      provides: "GraphQL query and mutation strings for key results"
      contains: "KEY_RESULTS_QUERY"
    - path: "src/services/perdoo/types.ts"
      provides: "KeyResult interface, UpsertKeyResultInput, response types"
      contains: "KeyResult"
    - path: "src/services/perdoo/client.ts"
      provides: "listKeyResults, getKeyResult, createKeyResult, updateKeyResult methods"
      contains: "listKeyResults"
    - path: "src/mcp/tools/key-results.ts"
      provides: "4 MCP tools: list_key_results, get_key_result, create_key_result, update_key_result"
      contains: "registerKeyResultTools"
    - path: "src/mcp/tools/index.ts"
      provides: "Key result tool registration call"
      contains: "registerKeyResultTools"
  key_links:
    - from: "src/mcp/tools/key-results.ts"
      to: "src/services/perdoo/client.ts"
      via: "client.listKeyResults/getKeyResult/createKeyResult/updateKeyResult calls"
      pattern: "client\\.(list|get|create|update)KeyResult"
    - from: "src/services/perdoo/client.ts"
      to: "src/services/perdoo/operations/key-results.ts"
      via: "imported query/mutation constants"
      pattern: "KEY_RESULTS_QUERY|KEY_RESULT_QUERY|UPSERT_KEY_RESULT"
    - from: "src/mcp/tools/index.ts"
      to: "src/mcp/tools/key-results.ts"
      via: "registerKeyResultTools import and call"
      pattern: "registerKeyResultTools"
---

<objective>
Introspect the Perdoo GraphQL schema for Key Result entities and implement full CRUD operations (list, get, create, update) as MCP tools, replicating the proven Phase 1 objectives pattern.

Purpose: Enables LLMs to manage key results in Perdoo, the primary vehicle for tracking measurable outcomes under objectives.
Output: 4 new MCP tools (list_key_results, get_key_result, create_key_result, update_key_result) backed by introspected, schema-correct GraphQL operations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-key-results-kpis/02-RESEARCH.md
@.planning/phases/01-foundation-objectives/01-03-SUMMARY.md

# Source files (Phase 1 patterns to replicate exactly):
@src/services/perdoo/operations/objectives.ts
@src/services/perdoo/types.ts
@src/services/perdoo/client.ts
@src/mcp/tools/objectives.ts
@src/mcp/tools/index.ts
@src/mcp/tools/error-handler.ts
@src/scripts/introspect.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Introspect Key Result schema and create operations + types</name>
  <files>src/services/perdoo/operations/key-results.ts, src/services/perdoo/types.ts</files>
  <action>
Run targeted __type introspection queries against the real Perdoo API to discover:

1. Key Result type fields:
   ```
   PERDOO_API_TOKEN=$PERDOO_API_TOKEN npx tsx -e "
   import { PerdooClient } from './src/services/perdoo/client.js';
   const client = new PerdooClient({ token: process.env.PERDOO_API_TOKEN!, circuitBreakerEnabled: false });
   const queries = [
     '{ __type(name: \"keyResult\") { name kind fields { name type { name kind ofType { name kind ofType { name kind } } } } } }',
     '{ __type(name: \"PerdooApiKeyResultTypeChoices\") { name kind enumValues { name } } }',
   ];
   for (const q of queries) {
     const r = await client.execute(q);
     console.log(JSON.stringify(r, null, 2));
   }
   "
   ```

2. Mutation discovery (find KR mutations):
   Run a query against the Mutation type looking for keyResult/KeyResult mutations:
   ```
   '{ __type(name: \"Mutation\") { fields { name args { name type { name kind ofType { name } } } } } }'
   ```
   Filter the output for fields containing "keyResult" or "KeyResult".

3. Input type introspection (once mutation name is found):
   Based on Phase 1 pattern, likely `UpsertKeyResultMutationInput`:
   ```
   '{ __type(name: \"UpsertKeyResultMutationInput\") { name kind inputFields { name type { name kind ofType { name kind ofType { name kind } } } } } }'
   ```

4. Verify whether singular `keyResult(id: UUID!)` query exists:
   Try executing `{ keyResult(id: "00000000-0000-0000-0000-000000000000") { id } }` -- if it errors with "Cannot query field", then use the `keyResults` list query with ID-based filtering, or try `goal(id: UUID!)`.

**CRITICAL:** Do NOT guess field names or mutation names. Use the real introspection output. Phase 1 proved that guessed operations fail.

After introspection, create the following files using the REAL discovered schema:

**src/services/perdoo/operations/key-results.ts:**
- `KEY_RESULTS_QUERY`: List query using the `keyResults(...)` root query with relay pagination. Include useful filter variables from research (objective, name_Icontains, lead_Id, type, archived, status_In, objectiveStage, timeframe, orderBy). Select all scalar fields + lead{id,name} + objective{id,name} + timeframe{id,name} for list view.
- `KEY_RESULT_QUERY`: Get-by-ID query (singular `keyResult(id: UUID!)` if it exists, otherwise filter `keyResults` by ID). Select ALL fields from introspection for full detail view.
- `UPSERT_KEY_RESULT_MUTATION`: Upsert mutation using discovered name and input type. Select core fields + objective reference in response.

Follow the exact pattern from `operations/objectives.ts`:
- JSDoc comments explaining the query
- Relay pagination structure (pageInfo + edges + node)
- UUID! scalar type for ID parameters
- Django-style filter arg names

**src/services/perdoo/types.ts (additions):**
- Add `KeyResult` interface with all fields from __type introspection
- Add `KeyResultsData` response type (connection wrapper)
- Add `KeyResultData` response type (singular wrapper)
- Add `UpsertKeyResultData` response type (mutation result with errors array)
- Add `UpsertKeyResultInput` interface from introspected input fields
- Add any new enums discovered (PerdooApiKeyResultTypeChoices, etc.)
- Reference existing types where applicable (PerdooUser, PerdooGroup, PerdooTimeframe, PerdooTag, CommitStatus, Connection, PageInfo)

**Important decisions from Phase 1 to carry forward:**
- IDs are UUID scalars (string in TS)
- Upsert pattern: id omitted = create, id included = update
- Django-style filter names (name_Icontains, lead_Id, etc.)
- Connection types use the existing Connection<T> generic
  </action>
  <verify>
- `npx tsc --noEmit` passes with no type errors
- key-results.ts exports KEY_RESULTS_QUERY, KEY_RESULT_QUERY, UPSERT_KEY_RESULT_MUTATION
- types.ts exports KeyResult, KeyResultsData, KeyResultData, UpsertKeyResultData, UpsertKeyResultInput
- All query/mutation strings use field names from actual introspection (not guessed)
  </verify>
  <done>
- Key Result operations file exists with schema-correct GraphQL queries/mutations
- Types file extended with KeyResult entity types matching real Perdoo schema
- TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add client methods and register Key Result MCP tools</name>
  <files>src/services/perdoo/client.ts, src/mcp/tools/key-results.ts, src/mcp/tools/index.ts</files>
  <action>
**src/services/perdoo/client.ts (additions):**

Add 4 typed methods following the exact pattern from objective methods:

1. `listKeyResults(params?)` - Calls execute with KEY_RESULTS_QUERY. Parameters include: first (default 20), after, objective (parent UUID), name_Icontains, lead_Id, type, archived, status_In, objectiveStage, timeframe, orderBy. Returns KeyResultsData.

2. `getKeyResult(id: string)` - Calls execute with KEY_RESULT_QUERY. Takes UUID string. Returns KeyResultData. If singular query doesn't exist, adjust to use list query with filtering.

3. `createKeyResult(input: Omit<UpsertKeyResultInput, 'id'>)` - Calls execute with UPSERT_KEY_RESULT_MUTATION, `{ isMutation: true }`. Returns UpsertKeyResultData.

4. `updateKeyResult(id: string, input: Omit<UpsertKeyResultInput, 'id'>)` - Calls execute with UPSERT_KEY_RESULT_MUTATION, spreads input with id, `{ isMutation: true }`. Returns UpsertKeyResultData.

Import the new operations and types at the top of the file.

**src/mcp/tools/key-results.ts (new file):**

Create `registerKeyResultTools(server: McpServer, client: PerdooClient): void` following the exact pattern from `tools/objectives.ts`:

1. `list_key_results` tool:
   - Description: "List Perdoo key results with pagination and filters. Can filter by parent objective, lead, type, status, timeframe. Returns flattened list."
   - Zod params: limit (1-100, default 20), cursor (optional), objective_id (optional, "Filter by parent objective UUID"), name_contains (optional), lead_id (optional), type (optional, use enum if PerdooApiKeyResultTypeChoices was discovered), archived (optional boolean), status (optional)
   - Handler: call client.listKeyResults, flatten edges/nodes, include pagination info, same response shape as list_objectives

2. `get_key_result` tool:
   - Description: "Get a single Perdoo key result by UUID with full details including objective reference, progress, and status."
   - Zod params: id (required string)
   - Handler: call client.getKeyResult, flatten all connection fields, return full detail

3. `create_key_result` tool:
   - Description: "Create a new key result under a Perdoo objective. Name and objective are required."
   - Zod params: name (required), objective (required, "Parent objective UUID"), plus other fields from UpsertKeyResultInput as optional, additional_fields record for extensibility
   - Handler: call client.createKeyResult, check result.errors, return success/id/name

4. `update_key_result` tool:
   - Description: "Update an existing Perdoo key result by UUID."
   - Zod params: id (required), all other fields optional, additional_fields record
   - Handler: call client.updateKeyResult, check result.errors, return success response

All tools must:
- Use handleToolError for error handling (import from ./error-handler.js)
- Log via logger.debug on entry
- Flatten relay connections for LLM consumption (no edges/node wrappers)
- Return JSON stringified response in { content: [{ type: 'text', text }] }

**src/mcp/tools/index.ts (modification):**

1. Import registerKeyResultTools from './key-results.js'
2. Call `registerKeyResultTools(server, client)` after the existing registerObjectiveTools call
3. Do NOT update INSTRUCTIONS_RESOURCE yet (that happens in Plan 02 with KPIs)
  </action>
  <verify>
- `npx tsc --noEmit` passes
- `npm run build` succeeds (if build script exists)
- Grep confirms: registerKeyResultTools is called in index.ts
- Grep confirms: client.ts has listKeyResults, getKeyResult, createKeyResult, updateKeyResult methods
- key-results.ts exports registerKeyResultTools function
  </verify>
  <done>
- Client has 4 typed Key Result methods (list, get, create, update)
- 4 MCP tools registered (list_key_results, get_key_result, create_key_result, update_key_result)
- Tools use Zod schemas with meaningful descriptions
- Relay connections flattened in tool responses
- Tools registered in index.ts
- TypeScript compiles and builds cleanly
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` -- all types correct
- `npm run build` -- compiles successfully
- Server starts: `PERDOO_API_TOKEN=test node dist/index.js` (verify no import errors)
- Key result tools appear in server tool list
</verification>

<success_criteria>
- 4 Key Result MCP tools operational (list, get, create, update)
- All GraphQL operations match real Perdoo schema (introspection-verified, not guessed)
- Client methods typed with proper input/output interfaces
- Tools flatten relay pagination for LLM consumption
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-key-results-kpis/02-01-SUMMARY.md`

Important: Save the introspection output for KPI types (kpi __type, KPI mutations, KPI input types) so Plan 02 can use it directly without re-running introspection.
</output>
