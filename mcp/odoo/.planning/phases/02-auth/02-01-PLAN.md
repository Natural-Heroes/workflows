---
phase: 02-auth
plan: 01
type: execute
wave: 1
depends_on: ["01-02"]
files_modified:
  - src/auth/credential-store.ts
  - src/auth/clients-store.ts
  - src/auth/provider.ts
  - src/auth/login-page.ts
autonomous: true

must_haves:
  truths:
    - "CredentialStore encrypts API keys with AES-256-GCM using a master key from env"
    - "CredentialStore can add, get, delete user credentials in SQLite"
    - "InMemoryClientsStore implements OAuthRegisteredClientsStore from the SDK"
    - "OdooOAuthProvider implements all 6 required OAuthServerProvider methods"
    - "authorize() redirects to /login with a pending authorization ID"
    - "verifyAccessToken() returns AuthInfo with extra.userId and extra.odooApiKey"
    - "Login page HTML includes form fields for Odoo login email and API key"
  artifacts:
    - path: "src/auth/credential-store.ts"
      provides: "Encrypted SQLite credential store mapping user IDs to Odoo API keys"
      exports: ["CredentialStore"]
    - path: "src/auth/clients-store.ts"
      provides: "In-memory OAuth registered clients store"
      exports: ["InMemoryClientsStore"]
    - path: "src/auth/provider.ts"
      provides: "OAuthServerProvider implementation for Odoo authentication"
      exports: ["OdooOAuthProvider"]
    - path: "src/auth/login-page.ts"
      provides: "Server-rendered HTML login form"
      exports: ["renderLoginPage"]
  key_links:
    - from: "src/auth/provider.ts"
      to: "src/auth/credential-store.ts"
      via: "credentialStore.getApiKey(userId) in verifyAccessToken()"
      pattern: "credentialStore"
    - from: "src/auth/provider.ts"
      to: "src/auth/clients-store.ts"
      via: "clientsStore getter returns InMemoryClientsStore"
      pattern: "clientsStore"
    - from: "src/auth/provider.ts"
      to: "src/auth/login-page.ts"
      via: "authorize() redirects to /login which renders login page"
      pattern: "/login"
---

<objective>
Implement the OAuth 2.1 authentication infrastructure: encrypted credential store, OAuth provider, client registration store, and login page.

Purpose: Build the auth layer that the MCP SDK's mcpAuthRouter will use to authenticate users, mapping their OAuth tokens to Odoo API keys stored encrypted in SQLite.
Output: Four modules that together implement the OAuthServerProvider interface, ready to be wired into the Express server in Plan 02-02.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-auth/02-RESEARCH.md
@.planning/phases/02-auth/02-CREDENTIAL-RESEARCH.md

Prior plan output (from Phase 1):
@src/lib/env.ts
@src/lib/logger.ts
@src/lib/errors.ts
@src/services/odoo/client.ts
@src/services/odoo/client-manager.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Credential store with AES-256-GCM encryption</name>
  <files>
    src/auth/credential-store.ts
  </files>
  <action>
    Create `src/auth/credential-store.ts`:

    1. Import crypto from 'node:crypto', Database from 'better-sqlite3', logger
    2. Export class CredentialStore:
       - constructor(options: { dbPath: string; masterKey: string })
       - Derive 256-bit encryption key using PBKDF2:
         * salt = Buffer.from('odoo-mcp-credential-salt-v1', 'utf8')
         * key = crypto.pbkdf2Sync(masterKey, salt, 100000, 32, 'sha256')
       - Initialize SQLite database:
         * db = new Database(dbPath)
         * db.pragma('journal_mode = WAL')
         * Call this.createSchema()

    3. Private createSchema():
       ```sql
       CREATE TABLE IF NOT EXISTS user_credentials (
         user_id TEXT PRIMARY KEY,
         encrypted_api_key TEXT NOT NULL,
         iv TEXT NOT NULL,
         auth_tag TEXT NOT NULL,
         created_at INTEGER NOT NULL,
         updated_at INTEGER NOT NULL
       );
       ```

    4. Private encrypt(plaintext: string): { ciphertext: string; iv: string; authTag: string }
       - const iv = crypto.randomBytes(12)  // 96-bit IV for GCM
       - const cipher = crypto.createCipheriv('aes-256-gcm', this.key, iv)
       - Encrypt plaintext, get auth tag
       - Return all as base64 strings

    5. Private decrypt(data: { ciphertext: string; iv: string; authTag: string }): string
       - Decode base64, create decipher, set auth tag, decrypt
       - On error: log and re-throw

    6. Public addOrUpdateUser(userId: string, apiKey: string): void
       - Encrypt the API key
       - UPSERT into user_credentials (INSERT ... ON CONFLICT DO UPDATE)
       - Log: logger.info('Credential stored', { userId })

    7. Public getApiKey(userId: string): string | null
       - SELECT encrypted data by user_id
       - If not found, return null
       - Decrypt and return

    8. Public deleteUser(userId: string): boolean
       - DELETE WHERE user_id = ?
       - Return result.changes > 0

    9. Public userExists(userId: string): boolean
       - SELECT 1 WHERE user_id = ?
       - Return !== undefined

    10. Public close(): void
        - this.db.close()

    11. Install better-sqlite3: `npm install better-sqlite3 && npm install --save-dev @types/better-sqlite3`
    12. Run `npx tsc --noEmit` to verify it compiles.
  </action>
  <verify>
    - `npx tsc --noEmit` exits 0
    - `grep "aes-256-gcm" src/auth/credential-store.ts` confirms encryption
    - `grep "pbkdf2Sync" src/auth/credential-store.ts` confirms key derivation
    - `grep "WAL" src/auth/credential-store.ts` confirms SQLite WAL mode
  </verify>
  <done>
    CredentialStore encrypts Odoo API keys with AES-256-GCM, stores in SQLite with WAL mode, supports CRUD operations. Master key derived via PBKDF2 from environment variable.
  </done>
</task>

<task type="auto">
  <name>Task 2: OAuth clients store and login page</name>
  <files>
    src/auth/clients-store.ts
    src/auth/login-page.ts
  </files>
  <action>
    1. Create `src/auth/clients-store.ts`:
       - Import OAuthRegisteredClientsStore from '@modelcontextprotocol/sdk/server/auth/clients.js'
       - Import OAuthClientInformationFull from '@modelcontextprotocol/sdk/shared/auth.js'
       - Export class InMemoryClientsStore implements OAuthRegisteredClientsStore:
         * private clients = new Map<string, OAuthClientInformationFull>()
         * async getClient(clientId: string): Promise<OAuthClientInformationFull | undefined>
           - return this.clients.get(clientId)
         * async registerClient(client: OAuthClientInformationFull): Promise<OAuthClientInformationFull>
           - this.clients.set(client.client_id, client)
           - logger.info('OAuth client registered', { clientId: client.client_id })
           - return client

    2. Create `src/auth/login-page.ts`:
       - Export function renderLoginPage(pendingId: string, error?: string): string
       - Return a complete HTML page with:
         * Clean, professional styling (no external dependencies)
         * Title: "Odoo MCP - Sign In"
         * Description: "Enter your Odoo credentials to connect"
         * Form with action="/login" method="POST":
           - Hidden input: name="pending" value={pendingId}
           - Text input: name="email" placeholder="Odoo login email" required
           - Password input: name="api_key" placeholder="Odoo API key" required
           - Help text: "Generate an API key in Odoo: Settings > Security > API Keys"
           - Submit button: "Sign In"
         * If error param provided, show red error message above the form
         * Mobile-responsive layout

    3. Run `npx tsc --noEmit` to verify both compile.
  </action>
  <verify>
    - `npx tsc --noEmit` exits 0
    - `grep "OAuthRegisteredClientsStore" src/auth/clients-store.ts` confirms SDK interface
    - `grep "renderLoginPage" src/auth/login-page.ts` confirms export
    - `grep "api_key" src/auth/login-page.ts` confirms form field
  </verify>
  <done>
    InMemoryClientsStore handles dynamic client registration. Login page renders a clean HTML form for users to enter their Odoo email and API key.
  </done>
</task>

<task type="auto">
  <name>Task 3: OAuth provider implementation</name>
  <files>
    src/auth/provider.ts
  </files>
  <action>
    Create `src/auth/provider.ts`:

    1. Imports:
       - { randomUUID } from 'crypto'
       - { Response } from 'express'
       - OAuthServerProvider, AuthorizationParams from '@modelcontextprotocol/sdk/server/auth/provider.js'
       - OAuthRegisteredClientsStore from '@modelcontextprotocol/sdk/server/auth/clients.js'
       - AuthInfo from '@modelcontextprotocol/sdk/server/auth/types.js'
       - OAuthClientInformationFull, OAuthTokens, OAuthTokenRevocationRequest from '@modelcontextprotocol/sdk/shared/auth.js'
       - { CredentialStore } from './credential-store.js'
       - { InMemoryClientsStore } from './clients-store.js'
       - { OdooClient } from '../services/odoo/client.js'
       - { logger } from '../lib/logger.js'

    2. Private interfaces:
       ```typescript
       interface CodeData {
         client: OAuthClientInformationFull;
         params: AuthorizationParams;
         userId: string;
         createdAt: number;
       }

       interface TokenData {
         clientId: string;
         userId: string;
         scopes: string[];
         expiresAt: number; // seconds since epoch
       }

       interface RefreshData {
         userId: string;
         clientId: string;
         scopes: string[];
       }

       interface PendingAuth {
         client: OAuthClientInformationFull;
         params: AuthorizationParams;
       }
       ```

    3. Export class OdooOAuthProvider implements OAuthServerProvider:
       - Private fields:
         * codes = new Map<string, CodeData>()
         * tokens = new Map<string, TokenData>()
         * refreshTokens = new Map<string, RefreshData>()
         * pendingAuths = new Map<string, PendingAuth>()
         * _clientsStore: InMemoryClientsStore

       - constructor(
           private readonly credentialStore: CredentialStore,
           private readonly odooUrl: string,
           private readonly odooDatabase: string,
         ):
         * this._clientsStore = new InMemoryClientsStore()

       - get clientsStore(): OAuthRegisteredClientsStore
         * return this._clientsStore

       - async authorize(client, params, res: Response): Promise<void>
         * const pendingId = randomUUID()
         * this.pendingAuths.set(pendingId, { client, params })
         * res.redirect(`/login?pending=${pendingId}`)
         * logger.info('OAuth authorize: redirecting to login', { clientId: client.client_id })

       - getPendingAuth(pendingId: string): PendingAuth | undefined
         * return this.pendingAuths.get(pendingId)

       - deletePendingAuth(pendingId: string): void
         * this.pendingAuths.delete(pendingId)

       - async completeAuthorization(pendingId: string, userId: string): Promise<{ code: string; redirectUri: string; state?: string }>
         * Get pending auth, if !found throw
         * const code = randomUUID()
         * this.codes.set(code, { client: pending.client, params: pending.params, userId, createdAt: Date.now() })
         * this.pendingAuths.delete(pendingId)
         * const targetUrl = new URL(pending.params.redirectUri)
         * targetUrl.searchParams.set('code', code)
         * if (pending.params.state) targetUrl.searchParams.set('state', pending.params.state)
         * return { code, redirectUri: targetUrl.toString(), state: pending.params.state }

       - async challengeForAuthorizationCode(_client, authorizationCode): Promise<string>
         * const codeData = this.codes.get(authorizationCode)
         * if (!codeData) throw new Error('Invalid authorization code')
         * return codeData.params.codeChallenge

       - async exchangeAuthorizationCode(client, authorizationCode, _codeVerifier?, _redirectUri?, _resource?): Promise<OAuthTokens>
         * Get code data, validate client_id matches, delete code
         * Generate access token (randomUUID) and refresh token (randomUUID)
         * const expiresIn = 3600 (1 hour)
         * Store token data: { clientId, userId, scopes, expiresAt: Math.floor(Date.now() / 1000) + expiresIn }
         * Store refresh token data: { userId, clientId, scopes }
         * Return OAuthTokens object
         * Log token issuance

       - async exchangeRefreshToken(client, refreshToken, scopes?, _resource?): Promise<OAuthTokens>
         * Get refresh data, validate client_id, delete old refresh token
         * Generate new access + refresh tokens (rotation)
         * Store new token and refresh data
         * Return OAuthTokens

       - async verifyAccessToken(token: string): Promise<AuthInfo>
         * Get token data, if !found throw new Error('Invalid token')
         * If expired (expiresAt < Math.floor(Date.now() / 1000)): delete, throw 'Token expired'
         * Get API key from credential store: this.credentialStore.getApiKey(data.userId)
         * If !apiKey throw new Error('User credentials not found')
         * Return AuthInfo: { token, clientId: data.clientId, scopes: data.scopes, expiresAt: data.expiresAt, extra: { userId: data.userId, odooApiKey: apiKey } }

       - async revokeToken(_client, request: OAuthTokenRevocationRequest): Promise<void>
         * this.tokens.delete(request.token)
         * this.refreshTokens.delete(request.token)

       - async validateOdooCredentials(email: string, apiKey: string): Promise<string | null>
         * Create temporary OdooClient(this.odooUrl, apiKey, this.odooDatabase)
         * try: call client.searchRead('res.users', [['login', '=', email]], ['id', 'login'], { limit: 1 })
         * If result has a match with login === email, return String(result[0].id)
         * On error: logger.warn('Odoo credential validation failed', { email, error }), return null

    4. Run `npx tsc --noEmit` to verify it compiles.
  </action>
  <verify>
    - `npx tsc --noEmit` exits 0
    - `grep "OAuthServerProvider" src/auth/provider.ts` confirms interface
    - `grep "verifyAccessToken" src/auth/provider.ts` confirms key method
    - `grep "credentialStore.getApiKey" src/auth/provider.ts` confirms credential lookup
    - `grep "expiresAt" src/auth/provider.ts` shows seconds-based expiry
  </verify>
  <done>
    OdooOAuthProvider implements all 6 OAuthServerProvider methods. authorize() redirects to login, verifyAccessToken() decrypts the user's Odoo API key from the credential store and returns it in AuthInfo.extra.odooApiKey. Token expiry uses seconds since epoch as required by the SDK.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- CredentialStore uses AES-256-GCM with 100k-iteration PBKDF2 key derivation
- OdooOAuthProvider.verifyAccessToken returns expiresAt in seconds (not milliseconds)
- OdooOAuthProvider.authorize redirects to /login (not inline form)
- InMemoryClientsStore implements the SDK's OAuthRegisteredClientsStore interface
- No console.log anywhere (only console.error via logger)
- No hardcoded secrets
</verification>

<success_criteria>
1. `npx tsc --noEmit` exits 0
2. CredentialStore can encrypt/decrypt API keys round-trip
3. OdooOAuthProvider implements authorize, challengeForAuthorizationCode, exchangeAuthorizationCode, exchangeRefreshToken, verifyAccessToken, revokeToken
4. verifyAccessToken returns { extra: { userId, odooApiKey } }
5. validateOdooCredentials calls Odoo JSON-2 API to verify the API key belongs to the claimed email
</success_criteria>

<output>
After completion, create `.planning/phases/02-auth/02-01-SUMMARY.md`
</output>
