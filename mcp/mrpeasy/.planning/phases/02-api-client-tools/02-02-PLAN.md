---
phase: 02-api-client-tools
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - mcp/mrpeasy/src/mcp/tools/inventory.ts
  - mcp/mrpeasy/src/mcp/tools/product.ts
  - mcp/mrpeasy/src/mcp/tools/search.ts
  - mcp/mrpeasy/src/mcp/tools/index.ts
autonomous: true
---

<objective>
Implement inventory, product, and search tools with Zod validation.

Purpose: First vertical slice of MCP tools covering product/inventory domain.
Output: Three working MCP tools: get_inventory, get_product, search_items.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-api-client-tools/02-01-SUMMARY.md

@mcp/mrpeasy/src/mcp/tools/index.ts
@mcp/mrpeasy/src/services/mrpeasy/client.ts
@mcp/mrpeasy/src/services/mrpeasy/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create get_inventory tool</name>
  <files>mcp/mrpeasy/src/mcp/tools/inventory.ts</files>
  <action>
Create MCP tool for fetching inventory/stock levels:

1. Import and use Zod for input schema validation:
   ```typescript
   import { z } from 'zod';
   ```

2. Define input schema with Zod:
   - item_id (optional string) - filter by specific item
   - warehouse_id (optional string) - filter by warehouse
   - page (optional number, default 1)
   - per_page (optional number, default 20, max 100)

3. Tool registration pattern:
   ```typescript
   export function registerInventoryTools(server: McpServer, client: MrpEasyClient) {
     server.tool(
       'get_inventory',
       'Get current stock levels and inventory costs. Filter by item_id or warehouse_id. Returns quantity on hand, reserved, available, and unit costs.',
       {
         item_id: z.string().optional().describe('Filter by specific item ID'),
         warehouse_id: z.string().optional().describe('Filter by warehouse ID'),
         page: z.number().int().positive().default(1).describe('Page number for pagination'),
         per_page: z.number().int().min(1).max(100).default(20).describe('Items per page (max 100)')
       },
       async (params) => { ... }
     );
   }
   ```

4. Handler implementation:
   - Validate params with Zod (SDK does this automatically)
   - Call client.getStockItems() with params
   - Format response for LLM consumption (clear, readable text)
   - Include pagination info in response

5. Response format (text for LLM):
   ```
   Inventory Results (Page X of Y):

   Item: [name] (ID: [id])
   - Quantity: [qty] [unit]
   - Reserved: [reserved]
   - Available: [available]
   - Unit Cost: $[cost]
   - Warehouse: [warehouse_name]

   [repeat for each item]

   Showing X-Y of Z total items.
   ```

Use logger for debug logging. Handle errors with isError: true pattern.
  </action>
  <verify>npx tsc --noEmit passes</verify>
  <done>get_inventory tool registered with Zod schema, returns formatted inventory data</done>
</task>

<task type="auto">
  <name>Task 2: Create get_product tool</name>
  <files>mcp/mrpeasy/src/mcp/tools/product.ts</files>
  <action>
Create MCP tool for fetching product details including BOM:

1. Define input schema:
   - product_id (required string) - the product to fetch
   - include_bom (optional boolean, default true) - include bill of materials

2. Tool description for LLM:
   'Get detailed product information including name, description, and bill of materials (BOM). Use this to understand product composition and manufacturing requirements.'

3. Handler:
   - Call client.getProduct(product_id)
   - Format product details clearly
   - If include_bom, format BOM as hierarchical list

4. Response format:
   ```
   Product: [name] (ID: [id])
   Part Number: [number]
   Description: [description]
   Type: [type]
   Unit: [unit]

   Bill of Materials:
   - [qty] x [component_name] (ID: [id])
     - [qty] x [sub_component] (ID: [id])
   [hierarchical structure]

   No BOM defined. (if empty)
   ```

Export registerProductTools function.
  </action>
  <verify>npx tsc --noEmit passes</verify>
  <done>get_product tool returns product details with formatted BOM</done>
</task>

<task type="auto">
  <name>Task 3: Create search_items tool</name>
  <files>mcp/mrpeasy/src/mcp/tools/search.ts</files>
  <action>
Create MCP tool for searching items by name or SKU:

1. Define input schema:
   - query (required string, min 2 chars) - search term
   - type (optional enum: 'product', 'part', 'material', 'all') - filter by item type
   - page (optional number, default 1)
   - per_page (optional number, default 20, max 100)

2. Tool description:
   'Search for items (products, parts, materials) by name or SKU/part number. Returns matching items with basic info. Use get_product for detailed product information.'

3. Handler:
   - Call client.getItems() with search params
   - Format results as list

4. Response format:
   ```
   Search Results for "[query]" (Page X of Y):

   1. [name] (ID: [id])
      Type: [type] | Part #: [number]

   2. [name] (ID: [id])
      Type: [type] | Part #: [number]

   [...]

   Found Z items matching "[query]".
   ```

Export registerSearchTools function.
  </action>
  <verify>npx tsc --noEmit passes</verify>
  <done>search_items tool searches and returns formatted results with pagination</done>
</task>

<task type="auto">
  <name>Task 4: Integrate tools into MCP server</name>
  <files>mcp/mrpeasy/src/mcp/tools/index.ts</files>
  <action>
Update the tools index to register all new tools:

1. Import all tool registration functions:
   - registerInventoryTools
   - registerProductTools
   - registerSearchTools

2. Import createMrpEasyClient factory

3. Update createMcpServer():
   - Create MrpEasy client instance
   - Call each register function with (server, client)
   - Keep the ping tool for testing

4. Pattern:
   ```typescript
   export function createMcpServer(): McpServer {
     const server = new McpServer({ name: 'mrpeasy-mcp', version: '0.1.0' });
     const client = createMrpEasyClient();

     // Register ping tool (keep for testing)
     server.tool('ping', ...);

     // Register MRPeasy tools
     registerInventoryTools(server, client);
     registerProductTools(server, client);
     registerSearchTools(server, client);

     return server;
   }
   ```

This centralizes tool registration while keeping tools in separate files.
  </action>
  <verify>npm run typecheck passes</verify>
  <done>All inventory/product/search tools registered and available via MCP</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run typecheck` passes
- [ ] All three tools registered: get_inventory, get_product, search_items
- [ ] Each tool has Zod schema validation
- [ ] Each tool has clear LLM-friendly description
- [ ] Response format is readable text, not raw JSON
- [ ] Pagination params work correctly
</verification>

<success_criteria>
- All tasks completed
- TypeScript compiles without errors
- 3 new tools available via MCP server
- Tools use the API client from Plan 02-01
</success_criteria>

<output>
After completion, create `.planning/phases/02-api-client-tools/02-02-SUMMARY.md`
</output>
