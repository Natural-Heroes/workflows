---
phase: 04-error-handling
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - mcp/mrpeasy/src/mcp/tools/inventory.ts
  - mcp/mrpeasy/src/mcp/tools/product.ts
  - mcp/mrpeasy/src/mcp/tools/search.ts
  - mcp/mrpeasy/src/mcp/tools/orders.ts
autonomous: true
---

<objective>
Update all MCP tools to use centralized error handling utilities for consistent, LLM-readable error responses.

Purpose: Every tool returns actionable, consistent error messages that help LLMs understand failures and recover gracefully.
Output: All 5 tools using McpToolError and formatErrorForMcp for error handling.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-error-handling/04-01-SUMMARY.md

@mcp/mrpeasy/src/lib/errors.ts
@mcp/mrpeasy/src/mcp/tools/inventory.ts
@mcp/mrpeasy/src/mcp/tools/product.ts
@mcp/mrpeasy/src/mcp/tools/search.ts
@mcp/mrpeasy/src/mcp/tools/orders.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tool error handler utility</name>
  <files>mcp/mrpeasy/src/mcp/tools/error-handler.ts</files>
  <action>
Create a shared error handler for all tools:

```typescript
/**
 * Shared error handler for MCP tools.
 * Converts various error types into LLM-friendly MCP responses.
 */

import { MrpEasyApiError, CircuitBreakerOpenError } from '../../services/mrpeasy/index.js';
import {
  createRateLimitError,
  createServiceUnavailableError,
  createAuthenticationError,
  createNotFoundError,
  createUnexpectedError,
  formatErrorForMcp,
} from '../../lib/errors.js';
import { logger } from '../../lib/logger.js';

/**
 * Handles errors from tool execution and returns MCP-compatible error response.
 *
 * @param error - The caught error
 * @param toolName - Name of the tool for logging
 * @returns MCP tool result with isError: true
 */
export function handleToolError(
  error: unknown,
  toolName: string
): { content: { type: string; text: string }[]; isError: true } {
  logger.error(`${toolName} error`, {
    error: error instanceof Error ? error.message : String(error),
  });

  // Handle MRPeasy API errors
  if (error instanceof MrpEasyApiError) {
    switch (error.status) {
      case 429:
        return formatErrorForMcp(createRateLimitError(error.retryAfterSeconds));
      case 503:
        return formatErrorForMcp(createServiceUnavailableError());
      case 401:
      case 403:
        return formatErrorForMcp(createAuthenticationError());
      case 404:
        return formatErrorForMcp(createNotFoundError('requested resource'));
      default:
        return formatErrorForMcp(createUnexpectedError(error));
    }
  }

  // Handle circuit breaker open
  if (error instanceof CircuitBreakerOpenError) {
    return formatErrorForMcp(createServiceUnavailableError());
  }

  // Handle unexpected errors
  return formatErrorForMcp(createUnexpectedError(error));
}
```

This provides a single entry point for all tool error handling.
  </action>
  <verify>npx tsc --noEmit passes</verify>
  <done>handleToolError function exported from error-handler.ts</done>
</task>

<task type="auto">
  <name>Task 2: Update inventory tool error handling</name>
  <files>mcp/mrpeasy/src/mcp/tools/inventory.ts</files>
  <action>
Replace the current catch block with the new error handler:

1. Import at top of file:
   ```typescript
   import { handleToolError } from './error-handler.js';
   ```

2. Replace the catch block in get_inventory:
   ```typescript
   } catch (error) {
     return handleToolError(error, 'get_inventory');
   }
   ```

3. Remove the inline error handling logic (the `error instanceof Error ? error.message : 'Unknown error occurred'` pattern).

4. Keep all other logic unchanged (params processing, API call, response formatting).
  </action>
  <verify>npm run typecheck passes</verify>
  <done>get_inventory uses handleToolError for consistent error responses</done>
</task>

<task type="auto">
  <name>Task 3: Update remaining tools error handling</name>
  <files>mcp/mrpeasy/src/mcp/tools/product.ts, mcp/mrpeasy/src/mcp/tools/search.ts, mcp/mrpeasy/src/mcp/tools/orders.ts</files>
  <action>
Apply the same pattern to all remaining tools:

**product.ts (get_product tool):**
1. Import handleToolError
2. Replace catch block with `return handleToolError(error, 'get_product');`

**search.ts (search_items tool):**
1. Import handleToolError
2. Replace catch block with `return handleToolError(error, 'search_items');`

**orders.ts (get_customer_orders and get_manufacturing_orders tools):**
1. Import handleToolError
2. Replace catch block in get_customer_orders with `return handleToolError(error, 'get_customer_orders');`
3. Replace catch block in get_manufacturing_orders with `return handleToolError(error, 'get_manufacturing_orders');`

Ensure all tools:
- Import from './error-handler.js'
- Use the tool name as second parameter for logging context
- Remove inline error message formatting
  </action>
  <verify>npm run typecheck passes</verify>
  <done>All 5 tools use handleToolError for consistent error responses</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run typecheck` passes
- [ ] error-handler.ts created with handleToolError function
- [ ] get_inventory uses handleToolError
- [ ] get_product uses handleToolError
- [ ] search_items uses handleToolError
- [ ] get_customer_orders uses handleToolError
- [ ] get_manufacturing_orders uses handleToolError
- [ ] All error responses include isError: true
- [ ] Error messages are LLM-friendly (complete sentences, actionable)
</verification>

<success_criteria>
- All tasks completed
- TypeScript compiles without errors
- All 5 tools return consistent, LLM-readable error messages
- Rate limit errors include retry guidance
- Service unavailable errors are clearly communicated
- Auth errors tell user to check credentials
</success_criteria>

<output>
After completion, create `.planning/phases/04-error-handling/04-02-SUMMARY.md`
</output>
